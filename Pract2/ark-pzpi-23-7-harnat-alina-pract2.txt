Міністерство освіти та науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук
Катедра програмної інженерії




ЗВІТ
до практичного завдання №2 з дисципліни
«Аналіз та рефакторинґ коду»
на тему: «Методи рефакторингу програмного коду»






Виконала:                                     Перевірив:
ст. гр. ПЗПІ-23-7                      				ст. викладач катедри ПІ
Гарнат Аліна Сергіївна	                      Сокорчук Ігор Петрович








Харків 2025
1 ІСТОРІЯ ЗМІН 

№	Дата	Версія звіту	Опис змін та виправлень
1	05.11.2025	1	Створено звіт

 
2	ЗАВДАННЯ

Студент повинен обрати три методи рефакторингу коду із книги Мартіна Фаулера «Refactoring. Improving the Design of Existing Code». Навести приклади свого особистого коду (з курсових, лабораторних або інших проєктів), який потребує покращення, та продемонструвати застосування обраних методів. Кожен метод рефакторингу повинен супроводжуватись:
-	Описом проблеми, яку вирішує даний метод.
-	Кодом до і після застосування методу рефакторингу.
-	Поясненням переваг використаного методу.
Для кожного стандарту оформлення необхідно розробити наочні приклади коду, які демонструватимуть як коректне, так і некоректне застосування правила, з детальними поясненнями щодо важливості дотримання кожного стандарту.
На основі проведеного дослідження студент має розробити презентацію українською мовою з мінімум 10 слайдів. Вступна частина повинна містити огляд обраної мови програмування, її історію розвитку та область застосування. Основна частина передбачає детальний розгляд конкретних стандартів оформлення з прикладами коду. Висновкова частина повинна включати аналіз важливості дотримання стандартів та їхнього впливу на якість коду. Презентація повинна бути структурованою, наочною та логічно послідовною.
Студент повинен завантажити презентацію на навчальну платформу dl.nure.ua та розмістити приклади коду у репозиторії на GitHub з детальною документацією.	 
3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1	Вступ
Рефакторинг — це процес удосконалення внутрішньої структури програмного коду без зміни його зовнішньої поведінки. Варто також підкреслити різницю між рефакторингом і переписуванням коду, оскільки ці два поняття зазвичай плутають. На відміну від переписування коду, рефакторинг коду не змінює функціональність програмного забезпечення: він лише очищає код, роблячи його простішим та оптимізованим.
3.2	 Мета рефакторингу
По-перше, зробити код чистішим. Рефакторинг допомагає зробити код зрозумілішим, логічно структурованим і зручним для читання. Завдяки цьому іншим розробникам (або навіть самому автору через деякий час) легше розібратися, як працює програма. 
По-друге, спростити логіку програми. Під час рефакторингу складні або громіздкі частини коду розбивають на менші, більш зрозумілі модулі, методи або класи. Це зменшує дублювання коду, підвищує повторне використання компонентів і покращує підтримку програми.
По-третє, полегшити майбутні зміни. Якісний, рефакторингований код легше розширювати, тестувати й модифікувати. Коли структура коду чітка, розробник може швидше додавати нові функції або виправляти помилки, не побоюючись зламати інші частини системи. 
По-четверте, покращити продуктивність команди. Коли код є зрозумілим і добре організованим, команда витрачає менше часу на пошук проблем і більше на розвиток продукту. 
Отже, рефакторинг — це інвестиція в майбутнє проєкту, що робить розробку стабільнішою, швидшою та ефективнішою.
3.3	 Метод 1 «Заміна кодування типу класом»
3.3.1 Опис методу
Метод рефакторингу, який передбачає заміну числового або символьного коду типу на окремий клас. Такий підхід: підвищує читабельність і надійність коду, дозволяє контролювати допустимі значення через типи, забезпечує гнучкість і легке розширення програми.
3.3.2 Проблема
У класі User тип користувача зберігається як звичайний рядок у полі UserType. Це означає, що можна записати будь-яке значення, навіть помилкове, наприклад "Admn" або "User", і програма все одно його прийме. Такий підхід ускладнює перевірку правильності даних і підвищує ризик логічних помилок у коді. Недоліками цього підходу є те, що в сеттерах поля часто немає ніяких перевірок на те, яке значення туди приходить, що може привести до великих проблем, якщо хтось відправить до цих полів якісь інші значення. Проблема також посилюється тим, що для таких полів неможливо зробити перевірку типів. У них можна відправити будь-яке число або рядок, і це значення залишиться зовсім без перевірки типів вашого середовища розробки і навіть при наявності помилок програма запуститься.
01 public class User
02 {
03     public string FirstName { get; set; }
04     public string LastName { get; set; }
05     public string Email { get; set; }
06     public string Password { get; set; }
07 
08     public string UserType { get; set; } 
09 }
3.3.3 Рішення
Замість використання звичайного рядка UserType створено окремий клас UserType, який інкапсулює логіку типів користувачів. Тепер тип користувача представлений як об’єкт класу UserType, що має обмежену кількість допустимих значень: Admin, Client, Carrier.
01 public class UserType
02 {
03     public static readonly UserType Admin = new UserType("Admin");
04     public static readonly UserType Client = new UserType("Client");
05     public static readonly UserType Carrier = new UserType("Carrier");
06 
07     public string Name { get; }
08 
09     private UserType(string name)
10     {
11         Name = name;
12     }
13 }
14 
15 public class User
16 {
17     public string FirstName { get; set; }
18     public string LastName { get; set; }
19     public string Email { get; set; }
20     public string Password { get; set; }
21 
22     public UserType Type { get; set; } 
23 }

3.4	 Перейменування методу
3.4.1	Опис методу
Полягає у зміні імені методу на більш зрозуміле, точне та таке, що краще відображає його призначення.
3.4.2 Проблема
Назва методу не розкриває суть того, що він робить.

01 public void delInvFlights(string path)
02 {
03   foreach (var flight in FlightsList)
04   {
05      if (flight.DateTime < DateTime.Now)
06      {
07        FlightsList.Remove(flight);
08        SaveFlightsData(path);
09       }
10    }
11	
3.4.3 Рішення
Метод мав нечітку назву, а скорочене слово «Invalid» не конкретизувало, які саме рейси видаляються. Після рефакторингу метод перейменовано на DeletePastFlights, що точніше відображає його функціональність - видалення рейсів, дата яких уже минула. Це покращує зрозумілість і підтримуваність коду.
01 public void DeletePastFlights(string path)
02 {
03     foreach (var flight in FlightsList)
04     {
05         if (flight.DateTime < DateTime.Now)
06         {
07             FlightsList.Remove(flight);
08             SaveFlightsData(path);
09         }
10     }
11 }

3.5 Переміщення методу
3.5.1 Опис методу
Метод рефакторингу, який використовується в іншому класі більше, ніж у власному.

3.5.2 Проблема
У класі Order знаходиться метод CalculateDiscount(), який відповідає за розрахунок знижки залежно від типу клієнта. Однак цей метод безпосередньо звертається до властивості Customer.Type, щоб визначити, яку саме знижку надати. Це створює зайву залежність між класами, адже тепер Order не лише зберігає інформацію про замовлення, а й знає логіку, пов’язану з клієнтом. Якщо в майбутньому з’являться нові типи клієнтів або зміниться система знижок, доведеться змінювати код саме в класі Order,
01 public class Customer
02 {
03     public string Name { get; private set; }
04     public string Type { get; private set; }
05 
06     public Customer(string name, string type)
07     {
08         Name = name;
09         Type = type;
10     }
11 }
12 
13 public class Order
14 {
15     public Customer Customer { get; private set; }
16     public double TotalPrice { get; private set; }
17 
18     public Order(Customer customer, double totalPrice)
19     {
20         Customer = customer;
21         TotalPrice = totalPrice;
22     }
23 
24     public double CalculateDiscount()
25     {
26         if (Customer.Type == "VIP")
27         {
28             return TotalPrice * 0.2;
29         }
30         if (Customer.Type == "Regular")
31         {
32             return TotalPrice * 0.1;
33         }
34         return 0;
35     }
36 }
3.5.3 Рішення
Щоб зменшити залежність між класами, метод CalculateDiscount() було перенесено в клас Customer, де тепер він має назву GetDiscount(). Таким чином, кожен клієнт сам "знає", яку знижку він має, а клас Order просто викликає цей метод і використовує результат у своїх розрахунках. Такий підхід робить код більш гнучким, зрозумілим і зручним для розширення, наприклад, тепер легко додати новий тип клієнта з власною системою знижок, не змінюючи клас Order.
01 public class Order
02 {
03     public Customer Customer { get; private set; }
04     public double TotalPrice { get; private set; }
05 
06     public Order(Customer customer, double totalPrice)
07     {
08         Customer = customer;
09         TotalPrice = totalPrice;
10     }
11 
12     public double FinalPrice
13     {
14         get 
15         { 
16             return TotalPrice - Customer.GetDiscount(TotalPrice); 
17         }
18     }
19 }
20 
21 public class Customer
22 {
23     public string Name { get; private set; }
24     public string Type { get; private set; }
25 
26     public Customer(string name, string type)
27     {
28         Name = name;
29         Type = type;
30     }
31 
32     public double GetDiscount(double totalPrice)
33     {
34         if (Type == "VIP")
35         {
36             return totalPrice * 0.2;
37         }
38         if (Type == "Regular")
39         {
40             return totalPrice * 0.1;
41         }
42         return 0;
43     }
44 }











ВИСНОВКИ

У результаті виконання практичної роботи було досліджено методи рефакторингу та пробедено рефакторинг коду. Проведення рефакторингу дозволило покращити структуру коду та зробити його більш зрозумілим і підтримуваним.
Завдяки використанню різних методів, таких як Replace Type Code with Class, Rename Method та Move Method, код став логічно організованим, а відповідальність між класами — чітко розподіленою. Це допомогло уникнути дублювання, зменшити кількість помилок, пов’язаних із неправильними типами даних, і зробити програму більш гнучкою до майбутніх змін.
Після рефакторингу код легше читати, розширювати та тестувати, що свідчить про покращення його якості, надійності та супровідності
 
ВИКОРИСТАНІ ДЖЕРЕЛА

1.	Martin Fowler — Refactoring: Improving the Design of Existing Code. URL:  https://martinfowler.com/books/refactoring.htmll (дата звернення: 05.11.2025).
2.	Refactoring Guru. Move Method. URL: https://refactoring.guru/uk/move-method (дата звернення: 05.11.2025).
3.	Refactoring Guru. Rename Method. URL: https://refactoring.guru/uk/move-method (дата звернення: 05.11.2025).
4.	Refactoring Guru.Replace Type Code with Class. URL: https://refactoring.guru/uk/move-method (дата звернення: 05.11.2025).
 
ДОДАТОК А
Відеозапис

Відеозапис доповіді: https://youtu.be/StGl4wEVyyo

Хронологічний опис відеозапису:
00:00 Вступ 
00:14 Визначення поняття рефакторингу 
00:48 Мета рефакторингу 
02:22 Метод 1. Заміна кодування типу класом. 
02:54 Метод 1. Проблема для вирішення 
04:05 Метод 1. Вирішення проблеми 
06:09 Метод 2. Перейменування методу 
06:25 Метод 2. Проблема для вирішення 
06:39 Метод 2. Вирішення проблеми 
07:18 Метод 3. Переміщення методу 
07:38 Метод 3. Проблема для вирішення 
08:28 Метод 3. Вирішення проблеми 
09:10 Висновки 
10:02 Перелік джерел










ДОДАТОК Б
Слайди презентації
 
Рисунок Б1 – Титульний слайд презентації

 
Рисунок Б2 – Поняття рефакторингу

 
Рисунок Б3 – Мета рефакторингу

 
Рисунок Б2 – Метод 1. Заміна кодування типу класом

 
Рисунок Б5 – Метод 1. Проблема для вирішення

 
Рисунок Б6 – Метод 1. Рішення проблеми

 
Рисунок Б7 – Метод 2. Перейменування методу

 
Рисунок Б8 – Метод 2. Проблема для вирішення

 
Рисунок Б9 – Метод 2. Рішення проблеми

 
Рисунок Б10 – Метод 3. Переміщення методу

 
Рисунок Б11 – Метод 3. Проблема для вирішення

 
Рисунок Б12 – Метод 3. Вирішення проблеми

 
Рисунок Б13 – Висновки

 
Рисунок Б14 – Перелік джерел

